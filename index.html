<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Global Azure Bootcamp 2019</title>

	<meta charset="utf-8">
	<meta name="description" content="Global Azure Bootcamp 2019">
	<meta name="author" content="Mike Branstein">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="container">
	<div id="header">
		<a href="#" class="menu header-btn" id="toggle-toc"></a>
		<h1>Global Azure Bootcamp 2019</h1>
		<a href="https://github.com/mikebranstein/global-azure-bootcamp-2019" class="github header-btn"></a>
	</div>

	<div id="content-container">
		<div id="toc">
			<div class="toc-heading">Table of Contents</div>
			<div id="toc-padding"></div>
			<br />
			<br />
			<br />
		</div>
		<div id="book">
			<div class="chapter">
				<h2 id="introduction">Introduction</h2>
<p>Welcome to Global Azure Bootcamp 2019! All around the world user groups and communities want to learn about Azure! On April 27, 2019, all communities will come together once again in the sixth great Global Azure Bootcamp event! Each user group will organize their own one day deep dive class on Azure the way they see fit and how it works for their members. The result is that thousands of people get to learn about Azure and join together online under the social hashtag #GlobalAzure!</p>
<h3 id="about-the-2019-louisville-global-azure-bootcamp">About the 2019 Louisville Global Azure Bootcamp</h3>
<p>The 2019 Louisville Global Azure Bootcamp is a free one-day global training event on Azure, from the community to the community. See our event <a href="https://global.azurebootcamp.net/locations/united-states-louisville/">home page</a> for more details. </p>
<p>This years format will be a blend of brief presentations, followed by hands-on and guided labs. </p>
<p>Our speakers include:</p>
<ul>
<li><a href="https://twitter.com/chadgreen">Chad Green</a><ul>
<li><a href="http://http://www.scholarrx.com/">ScholarRx</a></li>
<li><a href="http://www.codepalousa.com/">CodePaLOUsa</a></li>
<li><a href="http://www.chadgreen.com/">ChadGreen.com</a></li>
</ul>
</li>
<li><a href="https://twitter.com/mikebranstein">Mike Branstein</a><ul>
<li><a href="http://kizan.com">KiZAN Technologies</a></li>
<li><a href="https://brosteins.com">Brosteins</a></li>
</ul>
</li>
</ul>
<h3 id="getting-started">Getting Started</h3>
<p>To get started you&#39;ll need the following pre-requisites. Please take a few moments to ensure everything is installed and configured.</p>
<ul>
<li>Microsoft Windows PC or Mac or Linux. Just have a laptop.</li>
<li><a href="https://azure.microsoft.com">Azure Subscription</a> (Trial is ok, or an Azure account linked to a Visual Studio subscription. See later sections of this chapter to create a free trial account or activate your Visual Studio subscription)</li>
</ul>
<h3 id="what-you-re-building">What You&#39;re Building</h3>
<p>Azure is big. Really big. Too big to talk about all things Azure in a single day. </p>
<p>We&#39;ve assembled an exciting workshop to introduce you to several Azure services that cloud developers should know about:</p>
<ul>
<li><a href="https://azure.microsoft.com/en-us/services/app-service/web/">Web app</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/key-vault/">Key Vault</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/sql-database/">Azure SQL Database</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/event-hubs/">Event Hub</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/functions/">Azure Functions</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/api-management/">API Management</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/cosmos-db/">Cosmos DB</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/virtual-machines/">Virtual Machines</a></li>
</ul>
<p>In today&#39;s workshop, you&#39;ll get started with Azure and learn how to navigate through the Azure portal! You&#39;ll activate a free Azure subscription, learn about Resource Groups, and navigate through the Azure portal. You&#39;ll also create your development environment virtual machine running Visual Studio Community Edition.</p>
<p>Next, you&#39;ll learn about Platform as a Service (PaaS) offerings while creating a simple web app to manage data stored in an Azure SQL database. You&#39;ll finish by securing the data connection between your application and the database using an MSI (Managed Service Identity), then deploying to Azure services that host your web app.</p>
<p>Once your app is up and running, we&#39;ll teach you how your app can be restructured for scalability by separating the backend data access later into a separately-hosted ASP.NET Web API app. You&#39;ll also learn how to secure your service.</p>
<p>After you&#39;ve built and deployed a REST API, you&#39;ll learn how you can use Azure Functions and Cosmos DB to aggregate your data and ready it for consumption by the public.</p>
<p>Finally, after developing a database of publicly-consumable data, we&#39;ll explore how to advertise the data publicly as an API using App Services, Web API, and API Management. See how it&#39;s easy to have customers request access to the data, subscribe to your service, and generate additional revenue.</p>
<p>Essentially...</p>
<p><img src="images/chapter0/profit.jpeg"  /></p>
<h3 id="key-concepts-and-takeaways">Key concepts and takeaways</h3>
<ul>
<li>Navigating the Azure portal</li>
<li>Using Azure Resource Groups to manage multiple Azure services</li>
<li>Deploying a web app to Azure web app service</li>
<li>Decomposing an ASP.NET Core 2.2 MVC app into decoupled Web API services</li>
<li>Deploying an Azure SQL database</li>
<li>Using Events Hubs, Azure Functions, and Cosmos DB to develop an aggregated datastore</li>
<li>Using the Azure API Management service to create a subscription-based API offering  </li>
</ul>
<h3 id="agenda">Agenda</h3>
<ul>
<li>Chapter 0: Introduction</li>
<li>Chapter 1: Getting Started in Azure</li>
<li>Chapter 2: Connecting an Azure SQL Database</li>
<li>Chapter 3: Increasing the Security of Deployed Apps</li>
<li>Chapter 4: Decoupling Web Apps with a REST API Service Layer</li>
<li>Chapter 5: Comsuming a REST API</li>
<li>Chapter 6: Securing REST API Services with API Management</li>
<li>Chapter 7: Consuming a Secure REST API</li>
<li>Chapter 8: Introduction to the API Economy</li>
<li>Chapter 9: Using Cosmos DB to store Aggregated Data</li>
<li>Chapter 10: Exposing Aggregated Data for Profit</li>
</ul>
<h3 id="materials">Materials</h3>
<p>You can find additional lab materials and presentation content at the locations below:</p>
<ul>
<li>Presentation: <a href="https://github.com/mikebranstein/global-azure-bootcamp-2019">https://github.com/mikebranstein/global-azure-bootcamp-2019</a></li>
<li>Source code for the code used in this guide: <a href="https://github.com/mikebranstein/global-azure-bootcamp-2019">https://github.com/mikebranstein/global-azure-bootcamp-2019</a></li>
<li>This guide: <a href="https://github.com/mikebranstein/global-azure-bootcamp-2019-instructions/">https://github.com/mikebranstein/global-azure-bootcamp-2019-instructions</a></li>
</ul>
<h3 id="creating-a-bootcamp-trial-subscription">Creating a Bootcamp Trial Subscription</h3>
<p>There are several ways to get an Azure subscription, such as the free trial subscription, the pay-as-you-go subscription, which has no minimums or commitments and you can cancel any time; Enterprise agreement subscriptions, or you can buy one from a Microsoft retailer. In this exercise, you&#39;ll create a trial subscription using the code you were given at the bootcamp.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a Subscription with the Bootcamp Trial
</h4>

<p>Browse to <a href="https://www.microsoftazurepass.com/">https://www.microsoftazurepass.com/</a>.</p>
<p>Use the Azure Code on the handout you were given to get started.</p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>


<h3 id="creating-a-trial-azure-subscription">Creating a Trial Azure Subscription</h3>
<blockquote>
<p><strong>If you already have an Azure account</strong> </p>
<p>If you have an Azure account already, you can skip this section. If you have a Visual Studio subscription (formerly known as an MSDN account), you get free Azure dollars every month. Check out the next section for activating these benefits.</p>
</blockquote>
<p>There are several ways to get an Azure subscription, such as the free trial subscription, the pay-as-you-go subscription, which has no minimums or commitments and you can cancel any time; Enterprise agreement subscriptions, or you can buy one from a Microsoft retailer. In exercise, you&#39;ll create a free trial subscription.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a Free Trial Subscription
</h4>

<p>Browse to the following page <a href="http://azure.microsoft.com/en-us/pricing/free-trial/">http://azure.microsoft.com/en-us/pricing/free-trial/</a> to obtain a free trial account.</p>
<p>Click <em>Start free</em>.</p>
<p>Enter the credentials for the Microsoft account that you want to use. You will be redirected to the Sign up page.</p>
<blockquote>
<p><strong>Note</strong> </p>
<p>Some of the following sections could be omitted in the Sign up process, if you recently verified your Microsoft account.</p>
</blockquote>
<p>If you already ahve an Azure subscription tied to your Microsoft account, you may see a screen like this:</p>
<p><img src="images/chapter0/existing-subscription.png" class="img-medium" /></p>
<p>You&#39;re wekcome you use your existing subscription for the bootcamp. If you&#39;re planningto use your existing subscription, you can skip this exercise. Click <em>Sign Up</em> to create a new subscription.</p>
<p>Complete step 1 by entering your mobile phone number.</p>
<p><img src="images/chapter0/verify.png" class="img-medium" /></p>
<p>Select <em>Text me</em> or <em>Call me</em> to verify that you are a real person. Typein the verification code you receive on the phone or via text.</p>
<p>Next, complete the Payment information section.</p>
<blockquote>
<p><strong>A Note about your Credit Card</strong> </p>
<p>Your credit card will not be billed, unless you remove the spending limits. If you run out of credit, your services will be shut down unless you choose to be billed.</p>
</blockquote>
<p><img src="images/chapter0/payment.png" class="img-medium" /></p>
<p>Press <em>Next</em> after completing the credit card section.</p>
<p>In the <em>Technical Support</em> section, select the last option (No technical support) and click <em>Next</em>.</p>
<p><img src="images/chapter0/tech-support.png" class="img-medium" /></p>
<p>In the <em>Agreement</em> section, check the <em>I agree to the subscription Agreement</em>, <em>offer details</em>, and <em>privacy statement</em> option, and click <em>Sign up</em>.</p>
<p>Your free subscription will be set up, and after a while, you can start using it. Notice that you will be informed when the subscription expires.</p>
<p><img src="images/chapter0/agreement.png" class="img-medium" /></p>
<p>Your free trial will expire in 29 days from it&#39;s creation.</p>
<div class="exercise-end"></div>

<h3 id="activating-visual-studio-subscription-benefits">Activating Visual Studio Subscription Benefits</h3>
<p>If you happen to be a Visual Studio subscriber (formerly known as MSDN) you can activate your Azure Visual Studio subscription benefits. It is no charge, you can use your MSDN software in the cloud, and most importantly you get up to $150 in Azure credits every month. You can also get 33% discount in Virtual Machines and much more.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Activate Visual Studio Subscription Benefits
</h4>

<p>To active the Visual Studio subscription benefits, browse to the following URL: <a href="http://azure.microsoft.com/en-us/pricing/member-offers/msdn-benefits-details/">http://azure.microsoft.com/en-us/pricing/member-offers/msdn-benefits-details/</a></p>
<p>Scroll down to see the full list of benefits you will get for being a MSDN member. There is even a FAQ section you can read.</p>
<p>Click <em>Activate your monthly Azure credit</em> to activate the benefits.</p>
<p><img src="images/chapter0/activate.png" class="img-medium" /></p>
<p>You will need to enter your Microsoft account credentials to verify the subscription and complete the activation steps.</p>
<div class="exercise-end"></div>

<h3 id="preparing-your-azure-environment">Preparing your Azure environment</h3>
<p>You might be wondering how you can participate in a cloud development workshop and not need any software installed.</p>
<p>Thanks to the Azure Resource Manager and some nifty templates I put together, we&#39;re going to provision a virtual machine (VM) with Visual Studio (and all the tools you&#39;ll need) installed in your Azure subscription. From that point forward, you can work from the VM. </p>
<p>It takes about 10 minutes to get the VM deployed to your subscription, so let&#39;s get started!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Provisioning a Visual Studio Community VM in your Azure Subscription
</h4>

<p>Start by clicking the <em>Deploy to Azure</em> button below.</p>
<p><a href="https://portal.azure.com/#create/Microsoft.Template/uri/https%3A%2F%2Fraw.githubusercontent.com%2Fmikebranstein%2Fvscommunity-workshop-vm%2Fmaster%2Ftemplate.json" target="_blank"><img src="http://azuredeploy.net/deploybutton.png" class="img-override" /></a></p>
<p>This opens the Azure portal in a new tab of your browser. If you&#39;re prompted to sign in, do so. </p>
<p>When the page loads, you&#39;ll see this custom deployment page:</p>
<p><img src="images/chapter0/custom-deployment.png" class="img-override" /></p>
<h4 id="under-basics-select-enter-the-following">Under <em>Basics</em>, select/enter the following</h4>
<ul>
<li>Subscription: <em>your Azure subscription</em></li>
<li>Resource group: <em>Create new</em></li>
<li>Resource group name: <em>workshop-rg</em>, or some other name that&#39;s easy to remember</li>
<li>Location: <em>East US</em></li>
</ul>
<blockquote>
<p><strong>Resource Groups</strong> </p>
<p>Formally, resource groups provide a way to monitor, control access, provision and manage billing for collections of assets that are required to run an application, or used by a client or company department. Informally, think of resource groups like a file system folder, but instead of holding files and other folders, resource groups hold azure objects like storage accounts, web apps, functions, etc.</p>
</blockquote>
<blockquote>
<p><strong>Naming Resource Groups</strong> </p>
<p>I like to name my resource groups after their purpose, and append them with <em>-rg</em>, which signifies they are a resource group. </p>
</blockquote>
<h4 id="under-settings-enter">Under <em>Settings</em>, enter</h4>
<ul>
<li>Virtual Machine Name: <em>workshop-vm</em>, or some other name that is less than 15 characters long, and no special characters</li>
<li>Admin Username: <em>your first name</em>, or some other username without spaces</li>
<li>Admin Password: <em>P@ssW0rd1234</em>, or another 12-character password with upper, lower, numbers, and a special character </li>
</ul>
<blockquote>
<p><strong>WARNING</strong> </p>
<p>Do not forget your username and password. Write it down for today. </p>
</blockquote>
<h4 id="approving-the-purchase">Approving the &quot;Purchase&quot;</h4>
<p>Scroll down to the bottom of the page and click two boxes:</p>
<ol>
<li>I agree to the terms and conditions stated above</li>
<li>Pin to dashboard</li>
</ol>
<p>Press the <em>Purchase</em> button.</p>
<h4 id="deploying-the-vm">Deploying the VM</h4>
<p>After a few moments, the deployment of your VM will begin, and you&#39;ll see a status notification in the upper right:</p>
<p><img src="images/chapter0/deployment-start1.png" class="img-override" /></p>
<p>...and a deployment tile on your dashboard:</p>
<p><img src="images/chapter0/deployment-start2.png" class="img-override" /></p>
<p>Now, wait for about 10 minutes and your virtual machine will be deployed and ready to use.</p>
<div class="exercise-end"></div>

<p>That&#39;s it for the pre-requisites for today&#39;s workshop. Wait until your VM is created, and we&#39;ll be getting started soon!</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="getting-started-in-azure">Getting started in Azure</h2>
<h3 id="pre-requisites">Pre-requisites</h3>
<p>Before we go any further, be sure you have all the pre-requisites downloaded and installed. You&#39;ll need the following:</p>
<ul>
<li>Microsoft Windows PC or Mac</li>
<li>Evergreen web browser (Edge, Chrome, Firefox)</li>
<li><a href="https://azure.microsoft.com">Azure Subscription</a> (trial is ok, and you should have already done this in the chapter 0)</li>
<li>A Visual Studio Community edition VM running in Azure (see chapter 0 for setting this up)</li>
</ul>
<blockquote>
<p><strong>NOTE</strong></p>
<p>If you&#39;ve been following along, you should have all of these above items. </p>
</blockquote>
<h3 id="organizing-your-resources-in-the-azure-portal">Organizing your resources in the Azure portal</h3>
<p>One of the most important aspects of your Azure subscription and using the Azure portal is organization. You can create a lot of Azure resources very quickly in the portal, and it can become cluttered quickly. So, it&#39;s important to start your Azure subscription off right.</p>
<p>Our first stop will be to create a new Dashboard to organize our Azure resources we&#39;re building today.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a Dashboard
</h4>

<h4 id="creating-a-dashboard">Creating a Dashboard</h4>
<p>We&#39;ll start by creating a dashboard. </p>
<p>Login to the Azure portal, click <em>+</em>, give the dashboard name, and click <em>Done customizing</em>.</p>
<p><img src="images/chapter1/new-dashboard.gif" class="img-medium" /></p>
<p>That was easy! Dashboards are a quick way of organizing your Azure services. We like to create one for the workshop because it helps keep everything organized. You&#39;ll have a single place to go to find everything you build today.</p>
<h4 id="pinning-a-resource-group-to-the-dashboard">Pinning a Resource Group to the Dashboard</h4>
<p>Now that you have a new dashboard, let&#39;s put something on it. We&#39;ll be searching for the resource group you created in chapter 0 (the one that is holding your VM), and pinning it to this dashboard.</p>
<blockquote>
<p><strong>Resource Groups</strong> </p>
<p>You&#39;ll recall from the last chapter that resource groups provide a way to monitor, control access, provision and manage billing for collections of assets that are required to run an application, or used by a client or company department. Informally, think of resource groups like a file system folder, but instead of holding files and other folders, resource groups hold azure objects like storage accounts, web apps, functions, etc.</p>
</blockquote>
<p>Start by searching for the resource group you created in chapter 0. My resource group was called <em>workshop-rg</em>. </p>
<p><img src="images/chapter1/find-resource-group.gif" class="img-override" /></p>
<p>Click in the search bar at the top. If you&#39;re lucky your resource group will be at the very top (like mine was). If not, type it&#39;s name and click on it.</p>
<p>This opens the resource group. Next, click the <em>pin</em> icon at the upper-right to pin the resource group to your dashboard:</p>
<p><img src="images/chapter1/pin-resource-group.png" class="img-large" /></p>
<p>Finally, close the resource group, by clicking the <em>X</em> in the upper right corner (next to the <em>pin</em> icon). You should see the resource group pinned to your dashboard:</p>
<p><img src="images/chapter1/pinned.png" class="img-medium" /></p>
<p>Now that you have the VM&#39;s resource group pinned to your dashboard, it will be easy to locate the VM in later exercises.</p>
<p>Go ahead and click ont he Virtual machine, then pin it to the dashboard. When you&#39;re finished, you should see something like this:</p>
<p><img src="images/chapter1/vm-pin.gif" class="img-medium" /></p>
<p>That wraps up the basics of creating dashboard, creating resource groups, and pinning resources to a dashboard. We&#39;re not going to take a deep dive into Azure Resource Group. If you&#39;re interested in learning more, check out this <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-portal">article</a>.</p>
<h3 id="logging-into-your-virtual-machine">Logging into your virtual machine</h3>
<p>Next, let&#39;s get logged into the VM that we created in chapter 0. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Logging into your VM
</h4>

<p>Start by navigating to your Azure portal dashboard. </p>
<p>Locate the VM resource group you pinned earlier in this chapter and click on your virtual machine:</p>
<p><img src="images/chapter1/click-vm.png" class="img-override" /></p>
<p>Click the <em>Connect</em> button.</p>
<p><img src="images/chapter1/connect.png"/></p>
<p>This displays a download window on the right. Press the <em>Download RDP file</em> button.</p>
<p><img src="images/chapter1/connect-download.png" /></p>
<p>This downloads a file to your computer that will open in your Remote Desktop program.</p>
<p><img src="images/chapter1/connect-download-2.png" /></p>
<p>Click the downloaded file to open a connection to your VM. Enter your username and password you created earlier. </p>
<p><img src="images/chapter1/connect-password.png" class="img-override" /></p>
<p>Click <em>OK</em> to connect.</p>
<p>If you&#39;re prompted by a security message, respond <em>Yes</em>:</p>
<p><img src="images/chapter1/connect-security.png" class="img-override" /></p>
<p>You&#39;re now connected to your VM. </p>
<blockquote>
<p><strong>Download additional software</strong></p>
<p>If you&#39;re like me, you have a standard toolset you like to use. Please, download software for your VM and don&#39;t forget your browser of choice, Notepad++, Visual Studio Code, etc.</p>
</blockquote>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<p>Now that you&#39;re connected to your VM, you can continue to workshop from inside the VM. </p>
<blockquote>
<p><strong>Running a VM in Azure</strong> </p>
<p>If you&#39;re worried about excessive charges to your Azure subscription because you&#39;re running a VM constantly, don&#39;t worry. This VM is programmed to shut itself down every evening at 7:00 PM EST. </p>
</blockquote>
<h3 id="clone-project-from-master-branch">Clone project from master branch</h3>
<p>Let&#39;s get started by getting the <code>master</code> branch.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Getting the bootcamp files
</h4>

<p>Clone or download the <code>master</code> branch from <a href="https://github.com/mikebranstein/global-azure-bootcamp-2019">https://github.com/mikebranstein/global-azure-bootcamp-2019</a>.</p>
<p>Use this <a href="https://github.com/mikebranstein/global-azure-bootcamp-2019/archive/master.zip">link</a> to download a zip file of the <code>master</code> branch.</p>
<p><img src="images/chapter1/downloaded-zip.png" class="img-override" /></p>
<blockquote>
<p><strong>Unblock the .zip file!</strong> </p>
<p>Don&#39;t open the zip file yet. You may need to unblock it first!</p>
</blockquote>
<p>If you&#39;re running Windows, right-click the zip file and go to the properties option. Check the <em>Unblock</em> option, press <em>Apply</em>, press <em>Ok</em>.</p>
<p><img src="images/chapter1/unblock.gif" /></p>
<p>Now it&#39;s safe to unzip the file. </p>
<div class="exercise-end"></div>

<h3 id="about-contoso-university">About Contoso University</h3>
<p>The Contoso University web app is a small app that is used to manage the faculty, students, courses, and grades of Contoso University. It&#39;s not very advanced, but comes with pre-seeded data, and is ideal to demonstrate the concepts of this workshop.  </p>
<h3 id="verify-the-site-works">Verify the site works</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Compiling the solution
</h4>

<p>Before we can compile the solution, we need ot ensure .NET Core 2.2 is installed on your virtual machine.</p>
<p>Locate and run <em>Visual Studio Installer</em> from the Start Menu:</p>
<p><img src="images/chapter1/vs-installer.png" /></p>
<p>Select the <em>Modify</em> option under Visual Studio 2019:</p>
<p><img src="images/chapter1/modify.png" /></p>
<p>On the right, expand the section labeled <em>.NET Core cross-platform development</em>, and check the box labeled <em>.NET Core 2.2 development tools</em>.</p>
<p><img src="images/chapter1/core-22.png" /></p>
<p>Click the <em>Modify</em> button on the bottom to install. The install takes approx. 5 minutes to complete.</p>
<p>When the install is finished, you can update Visual Studio 2019 to the latest version (if you want), but it isn&#39;t necessary.</p>
<p>Next, open the solution in <strong>Visual Studio 2019</strong> by double-clicking the <code>ContosoUniversity.sln</code> file in the <em>src</em> folder of the extracted files:</p>
<p><img src="images/chapter1/solution-file.png" /></p>
<blockquote>
<p><strong>Logging into Visual Studio the first time</strong></p>
<p>When you open Visual Studio the first time, it may take a few minutes. Be patient. You&#39;ll probably be prompted to sign in. Use your Microsoft account to sign in (the same one you used to sign up for the Azure trial).</p>
</blockquote>
<p>The opened solution should look like this:</p>
<p><img src="images/chapter1/opened-solution.png" /></p>
<p>Build and debug the solution. You should see the Speech Recognition site load in your browser.</p>
<p><img src="images/chapter1/site.png" /></p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<p>That&#39;s it! You&#39;re up and running and ready to move on! In the next section, you&#39;ll learn how to deploy your website to Azure.</p>
<h3 id="understanding-app-service-and-web-apps">Understanding App Service and Web Apps</h3>
<p>In the last part of this chapter, you&#39;ll learn how to create an Azure Web App and deploy the Speech Service website to the cloud. In short, I like to think of Azure Web Apps like IIS in the cloud, but without the pomp and circumstance of setting up and configuring IIS.</p>
<p>Web Apps are also part of a larger Azure service called the App Service, which is focused on helping you to build highly-scalable cloud apps focused on the web (via Web Apps), mobile (via Mobile Apps), APIs (via API Apps), and automated business processes (via Logic Apps). </p>
<p>We don&#39;t have time to fully explore all of the components of the Azure App Service, so if you&#39;re interested, you can read more <a href="https://azure.microsoft.com/en-us/services/app-service/">online</a>.</p>
<h4 id="what-is-an-azure-web-app-">What is an Azure Web App?</h4>
<p>As we&#39;ve mentioned, Web Apps are like IIS in the cloud, but calling it that seems a bit unfair because there&#39;s quite a bit more to  Web Apps:</p>
<ul>
<li><p><strong>Websites and Web Apps:</strong> Web Apps let developers rapidly build, deploy, and manage powerful websites and web apps. Build standards-based web apps and APIs using .NET, Node.js, PHP, Python, and Java. Deliver both web and mobile apps for employees or customers using a single back end. Securely deliver APIs that enable additional apps and devices.</p>
</li>
<li><p><strong>Familiar and fast:</strong> Use your existing skills to code in your favorite language and IDE to build APIs and apps faster than ever. Access a rich gallery of pre-built APIs that make connecting to cloud services like Office 365 and Salesforce.com easy. Use templates to automate common workflows and accelerate your development. Experience unparalleled developer productivity with continuous integration using Visual Studio Team Services, GitHub, and live-site debugging.</p>
</li>
<li><p><strong>Enterprise grade:</strong> App Service is designed for building and hosting secure mission-critical applications. Build Azure Active Directory-integrated business apps that connect securely to on-premises resources, and then host them on a secure cloud platform that&#39;s compliant with ISO information security standard, SOC2 accounting standards, and PCI security standards. Automatically back up and restore your apps, all while enjoying enterprise-level SLAs.</p>
</li>
<li><p><strong>Build on Linux or bring your own Linux container image:</strong> Azure App Service provides default containers for versions of Node.js and PHP that make it easy to quickly get up and running on the service. With our new container support, developers can create a customized container based on the defaults. For example, developers could create a container with specific builds of Node.js and PHP that differ from the default versions provided by the service. This enables developers to use new or experimental framework versions that are not available in the default containers.</p>
</li>
<li><p><strong>Global scale:</strong> App Service provides availability and automatic scale on a global datacenter infrastructure. Easily scale applications up or down on demand, and get high availability within and across different geographical regions. Replicating data and hosting services in multiple locations is quick and easy, making expansion into new regions and geographies as simple as a mouse click.</p>
</li>
<li><p><strong>Optimized for DevOps:</strong> Focus on rapidly improving your apps without ever worrying about infrastructure. Deploy app updates with built-in staging, roll-back, testing-in-production, and performance testing capabilities. Achieve high availability with geo-distributed deployments. Monitor all aspects of your apps in real-time and historically with detailed operational logs. Never worry about maintaining or patching your infrastructure again.</p>
</li>
</ul>
<h3 id="deploying-to-a-web-app-from-visual-studio">Deploying to a Web App from Visual Studio</h3>
<p>Now that you understand the basics of web apps, let&#39;s create one and deploy our app to the cloud! </p>
<p>Earlier in this chapter, you created a resource group to house resources for this workshop. You did this via the Azure Portal. You can also create Web Apps via the Azure portal in the same manner. But, I&#39;m going to show you another way of creating a Web App: from Visual Studio.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Deploying to a Web App from Visual Studio 2017
</h4>

<blockquote>
<p><strong>Visual Studio 2019 Warning</strong> </p>
<p>This exercise assumes you&#39;re running Visual Studio 2019. If you&#39;re not, please do.</p>
</blockquote>
<p>From Visual Studio, right-click the <em>ContosoUniversity</em> project and select <em>Publish</em>. In the web publish window, select <em>Microsoft Azure App Service</em>, <em>Create New</em>, and press <em>Publish</em>. This short clip walks you through the process:</p>
<p><img src="images/chapter1/publish-web-app.gif" class="img-large" /></p>
<p>On the next page, give your Web App a name, select your Azure subscription, and select the Resource Group you created earlier (mine was named <em>workshop-rg</em>), and create a new Free App Service Plan. Read below for more details.</p>
<blockquote>
<p><strong>Unique Web App Names</strong></p>
<p>Because a web app&#39;s name is used as part of it&#39;s URL in Azure, you need to ensure it&#39;s name is unique. Luckily, Visual Studio will check to ensure your web app name is unique before it attempts to create it. In other words, don&#39;t try to use the web app name you see below, because I already used it.</p>
</blockquote>
<p><img src="images/chapter1/web-app-settings.png" class="img-override" /></p>
<p>Click <em>New...</em> to create a new Web App plan.</p>
<blockquote>
<p><strong>Web App Plans</strong> </p>
<p>Web App plans describe the performance needs of a web app. Plans range from free (where multiple web apps run on shared hardware) to not-so-free, where you have dedicated hardware, lots of processing power, RAM, and SSDs. To learn more about the various plans, check out this <a href="https://azure.microsoft.com/en-us/pricing/details/app-service/plans/">article</a>.</p>
</blockquote>
<p>Create a new free plan.</p>
<p><img src="images/chapter1/new-plan.png" /></p>
<p>After the plan is created, click <em>Create</em> to create the Web App in Azure.</p>
<p>When the Azure Web App is created in Azure, Visual Studio will publish the app to the Web App. After the publish has finished, your browser window will launch, showing you your deployed website. </p>
<blockquote>
<p><strong>Web App URLs</strong></p>
<p>The deployed web app has a URL of <em>Web App Name</em>.azurewebsites.net. Remember this URL, because you&#39;ll be using it in later chapters.</p>
</blockquote>
<p>One final note is to check the Azure Portal to see the App Service plan and Web App deployed to your resource group:</p>
<p><img src="images/chapter1/deployed-webapp.png" class="img-override" /></p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>
			</div>
			<hr>
			<div class="chapter">
				<h2 id="connecting-an-azure-sql-database">Connecting an Azure SQL Database</h2>
<p>In this chapter you&#39;ll learn about Azure SQL Database, how to provision one in the Azure Portal, and how to use Entity Framework Core (EF Core) to seed a local (development database) and an Azure SQL Database.</p>
<h3 id="overview">Overview</h3>
<p>Azure SQL Database is a general-purpose relational database-as-a-service (DBaaS) based on the latest stable version of Microsoft SQL Server Database Engine. SQL Database is a high-performance, reliable, and secure cloud database that you can use to build data-driven applications and websites in the programming language of your choice, without needing to manage infrastructure.</p>
<h3 id="provisioning-in-azure">Provisioning in Azure</h3>
<p>Now that you know what Azure SQL Database can do, let&#39;s start using it! You&#39;ll start by creating a SQL Database instance in the Azure portal. </p>
<blockquote>
<p><strong>SQL Servers and Databases</strong></p>
<p>When creating a SQL Database, you also need to create a SQL Server. The steps below walk you through this process.</p>
</blockquote>
<h4 class="exercise-start">
    <b>Exercise</b>: Creating a SQL Server and Database instance
</h4>

<p>Start by jumping back to the Azure portal, and create a new resource by clicking the <em>Create a resource</em> button.</p>
<p>Search for <em>SQL Database</em>:</p>
<p><img src="images/chapter2/sql-search.png" class="img-medium" /></p>
<p>Fill out the required parameters as you create an instance:</p>
<ul>
<li>Resource group: the resource group you created earlier</li>
<li>Database name: ContosoUniversity3</li>
<li>Server: <em>Press Create new button</em>, complete right side panel</li>
<li>Server name: unique SQL server name to create</li>
<li>Server admin login: workshopAdmin</li>
<li>Password: <em>Enter complex password</em>, write it down</li>
<li>Location: East US</li>
</ul>
<p><img src="images/chapter2/create-sql.png" class="img-override" /></p>
<p>Press the <em>Select</em> button after completing the server information in the right panel, then press <em>Review and create</em>.</p>
<p><img src="images/chapter2/sql-review-create.png" /></p>
<p>When the SQL Server and database instances are provisioned, they appear in your resource group:</p>
<p><img src="images/chapter2/sql-deployed.png" class="img-override" /></p>
<p>The final step is to navigate to the SQL Server instance by clicking on it. </p>
<blockquote>
<p><strong>Secured by default</strong></p>
<p>As with most Azure resources, SQL Server is secured by default, meaning that you cannot access the SQL Server or databases without opening up the attached firewall. In this next step, we&#39;ll do just that.</p>
</blockquote>
<p>Locate the <em>Firewalls and virtual networks</em> area, click <em>Show firewall settings</em>.</p>
<p><img src="images/chapter2/sql-firewall.png" class="img-override" /></p>
<p>Click the <em>Add client IP</em> button and notice an entry being made in the table below. Then, click <em>Save</em>. This opens the SQL Server firewall to allow you to communicate with it directly for the duration of the workshop.</p>
<p><img src="images/chapter2/add-client-ip.png" class="img-override" /></p>
<p>Next, navigate to the <em>SQL Databases</em> link on the left, and select the ContosoUniversity3 database.</p>
<p><img src="images/chapter2/nav-sql.png" class="img-medium" /></p>
<p>Click the <em>Show database connection strings</em> link:</p>
<p><img src="images/chapter2/conn-strings.png" class="img-override" /></p>
<p>Copy the connection string and paste it into Notepad, or another text editor:</p>
<p><img src="images/chapter2/copy-conn-string.png" class="img-override" /></p>
<p>After pasting the connections tring into a text editor, locate the <code>{your_username}</code> and <code>{your_password}</code> sections and update them with the SQL Server username and password you created previously.</p>
<p><img src="images/chapter2/update-conn-string.png" class="img-medium" /></p>
<p>Save this connection string -- you&#39;ll need it later!</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>

<h3 id="seeding-your-databases">Seeding your databases</h3>
<p>You may have noticed that the Contoso University app crashes when you navigate to various pages. That&#39;s because it&#39;s expecting a database exists, but we haven&#39;t created it.</p>
<p>In this next step, we&#39;ll use Entity Framework&#39;s Migrations to create and seed a local SQL database, then do the same for the Azure SQL Database we just created.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Seeding the local SQL Database
</h4>

<p>Every installation of Visual Studio 2019 comes with a development version of SQL Server called MS SQL Local DB. In fact, the Contoso University app is pre-configured to use this SQL Server instance already.</p>
<p>Open the <code>appsettings.json</code> file to see the connection string:</p>
<pre><code class="lang-json">&quot;ConnectionStrings&quot;: {
    &quot;DefaultConnection&quot;: &quot;Server=(localdb)\\mssqllocaldb;Database=ContosoUniversity3;Trusted_Connection=True;MultipleActiveResultSets=true&quot;
  }
</code></pre>
<p>Notice the server name of <strong>(localdb)\mssqllocaldb</strong>. This is the local development version of SQL I mentioned above. We&#39;ll use this in the next section to &quot;seed&quot; the database with Entity Framework Migrations.</p>
<blockquote>
<p><strong>Entity Framework and Migrations</strong></p>
<p>If you&#39;re not familiar with Entity Framework and Migrations, don&#39;t worry. Entity Framework (EF) is a technology called an object-relational mapper (O/RM). O/RMs (like EF) enable .NET developers to work with a database using .NET objects, and eliminating the need for most of the data-access code they usually need to write (like stored procedures, views, and queries). </p>
<p>EF Migrations are a way to use .NET objects and code to create a SQL database and tables, then seed the database with preliminary data.</p>
</blockquote>
<p>The Contoso University app already has Entity Framework installed and configured. Let&#39;s use it to create the ContosoUniversity3 database locally by running the migrations.</p>
<h4 id="using-ef-migrations">Using EF Migrations</h4>
<p>In Visual Studio, go to the <em>Tools</em> menu, select <em>NuGet Package Manager</em>, then <em>Package Manager Console</em>.</p>
<p><img src="images/chapter2/open-pm.png" class="img-medium" /></p>
<p>This opens a new area at the bottom of Visual Studio:</p>
<p><img src="images/chapter2/pm-console.png" class="img-medium" /></p>
<p>In the Package Manager Console, change the Default project to <em>ContosoUniversityData</em>, the type <em>Update-Database</em> and press <em>Enter</em>. The EF Migrations will read the connection string from your configuration file, create the ContosoUniversity3 database, create the tables, and load seed data into the tables. You can see the process happening below:</p>
<p><img src="images/chapter2/ef-migrations.gif" class="img-medium" /></p>
<p>When the EF Migrations have finished, run the web site, and navigate to the <em>Courses</em> page. You will see the page displays a variety of course data:</p>
<p><img src="images/chapter2/courses.png" class="img-medium" /></p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>

<p>Now that you&#39;ve used EF Migrations, let&#39;s seed the ContosoUniversity3 database in Azure. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Seeding the Azure SQL Database
</h4>

<p>Open the <code>appsettings.json</code> file to adjust the connection string. You&#39;llrecall that we saved the Azure SQL Database connection string in our text editor earlier. Copy the value and paste it into the configuration file.</p>
<p>Mine looks like:</p>
<p><img src="images/chapter2/appsettings.png" class="img-medium" /></p>
<p>Now that the connection string has been updated, return to the Package Manager Console and run the EF Migrations again.</p>
<blockquote>
<p><strong>ContosoUniversityData project</strong></p>
<p>Don&#39;t forget to change the default project to ContosoUniversityData before running the migrations.</p>
</blockquote>
<pre><code>&gt; Update-Database
</code></pre><p>This will use the updated connection string to provision and seed the ContosoUniversity3 database in Azure.</p>
<p>When the migrations have finished, run the website to verify it still works. </p>
<p>Now, as a final step, re-deploy your web app to Azure, so it has the updated connection string (pointing to your Azure SQL Database).</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>

<p>That&#39;s it. In the next chapter, you&#39;ll learn how to secure your connection string so it isn&#39;t visible int he configuration file.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="increasing-the-security-of-deployed-apps">Increasing the Security of Deployed Apps</h2>
<p>In this chapter, you&#39;ll learn:</p>
<ul>
<li>How to secure secrets (like SQL databse connection strings) with Key Vaults</li>
<li>How to add authentication to your web apps instantly</li>
</ul>
<h3 id="securing-secrets-in-web-apps">Securing Secrets in Web Apps</h3>
<p>Since the early days of .NET, developers have been putting SQL database connection strings in configuration files. This is not only a bad practice, but a serious security risk for several reasons:</p>
<ul>
<li>login credentials are saved in plain-text </li>
<li>it&#39;s easy to accidentally check in the credentials</li>
</ul>
<p>Because of the risks of plain-text credentials, developers started encrypting the vaules, but this brought challenges with how to encrypt and decrypt, and made a developer&#39;s job more difficult.</p>
<p><img src="images/chapter3/better-way.gif" /></p>
<p>There&#39;s got to be a better way!</p>
<h4 id="key-vault-to-the-rescue-">Key Vault to the Rescue!</h4>
<p>Introducing Key Vault! Azure Key Vault helps solve the following problems:</p>
<ul>
<li><strong>Secrets Management</strong>: Azure Key Vault can be used to Securely store and tightly control access to tokens, passwords, certificates, API keys, and other secrets</li>
<li><strong>Key Management</strong>: Azure Key Vault can also be used as a Key Management solution. Azure Key Vault makes it easy to create and control the encryption keys used to encrypt your data.</li>
<li><strong>Certificate Management</strong>: Azure Key Vault is also a service that lets you easily provision, manage, and deploy public and private Secure Sockets Layer/Transport Layer Security (SSL/TLS) certificates for use with Azure and your internal connected resources.</li>
<li><strong>Store secrets backed by Hardware Security Modules</strong>: The secrets and keys can be protected either by software or FIPS 140-2 Level 2 validates HSMs</li>
</ul>
<p>So, with Key Vault, you store your connection strings inside of a secret store instead of in your app configuration file. Then, you simply store the location or URL of the Key Vault in your config file, so when your app starts up, you access the Key Vault, extract your secrets, then continue on as normal.</p>
<blockquote>
<p><strong>But wait...don&#39;t I need a secret/password to access a Key Vault</strong></p>
<p>Yes you do, but it doesn&#39;t make much sense to store that secret inside of your app configuration file. Afterall, that&#39;s exactly what we&#39;re trying to avoid!</p>
</blockquote>
<h4 id="accessing-keyvault-without-a-password">Accessing KeyVault without a Password</h4>
<p>That&#39;s right. You can actually access the Key Vault without a password - at least a password that you&#39;re aware of. </p>
<p>The second critical component to securing your app secrets is something called a Managed Service Identity (or MSI for short). You can think of an MSI like a service account, but a service account that doesn&#39;t have a password. </p>
<p>Within Azure, you can assign an MSI to a Web App, so when the app runs it &quot;acts&quot; or &quot;takes on&quot; the role of the MSI. So, once it&#39;s been assigned to a Web App, you can give the Web App MSI permissions to access your Key Vault. </p>
<p>To the developer, this seems like magic - when you app runs, it becomes an MSI, then has permissions to access the Key Vault without a password. But behind the scenes Azure is managing the entire process, ensuring your Web App is the only resource using the assigned MSI.</p>
<h3 id="assigning-an-msi-to-your-web-app">Assigning an MSI to your Web App</h3>
<p>Let&#39;s get started by assigning an MSI to your web app!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Assigning an MSI through the Azure Portal
</h4>

<p>Navigate to the web app you deployed in an earlier chapter. Mine was called <em>contoso-web-meb</em>.</p>
<p>Scroll down on the left to find a section named <em>Identity</em>. Click on <em>Identity</em>:</p>
<p><img src="images/chapter3/identity.png" class="img-medium" /></p>
<p>On the <em>System assigned</em> tab, change the status to <em>On</em> and press <em>Save</em>.</p>
<p><img src="images/chapter3/system-assigned.png" class="img-medium" /></p>
<p>Click <em>Yes</em> when prompted.</p>
<p><img src="images/chapter3/accept.png" class="img-override" /></p>
<p>...and that&#39;s it! Your MSI (Managed Service Identity) is assigned. </p>
<p><img src="images/chapter3/assigned.png" class="img-override" /></p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div> 

<h3 id="creating-a-key-vault">Creating a Key Vault</h3>
<p>Now that you have an MSI assigned to your web app, it&#39;s time to create a Key Vault and give the MSI access to read secrets.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Creating a Key Vault and Assigning Access
</h4>

<p>In the Azure portal, search for the Key Vault by searching for it, like you did the SQL Database in an earlier chapter.</p>
<p><img src="images/chapter3/search-kv.png" class="img-medium" /></p>
<p>Place the Key Vault in the resource group you created for the workshop:</p>
<p><img src="images/chapter3/create-kv.png" /></p>
<p>Click the <em>Access policies</em> section, then the <em>+ Add new</em> link to add the web app MSI to the Key Vault&#39;s authorized users:</p>
<p><img src="images/chapter3/access-policies-kv.png" class="img-medium" /></p>
<p>Do the following:</p>
<ol>
<li>Select <em>Secret management</em> from the <em>Configure from template</em> option</li>
<li>Click <em>Select principal</em></li>
<li>In the box to the right, type the name of your web app (mine was contoso-web-meb)</li>
<li>Click your web app&#39;s name when it appears below</li>
<li>Click the <em>Select</em> button</li>
<li>Click <em>Ok</em></li>
</ol>
<p>You should now see your web app added:</p>
<p><img src="images/chapter3/added.png" class="img-medium" /></p>
<p>Click <em>Ok</em> to return to the Key Vault creation screen, and <em>Create</em> to provision the Key Vault.</p>
<p>It will take a few minutes to deploy the Key Vault. When it&#39;s finished provisioning, pin it to your dashboard (we&#39;ll be using it a lot today).</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div> 


<h3 id="adding-secrets-to-the-key-vault">Adding Secrets to the Key Vault</h3>
<p>Now that you have created a Key Vault and assigned access to it, let&#39;s add a secret!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Adding a secret to a Key Vault
</h4>

<p>Navigate to your Key Vault and select the <em>Secrets</em> area on the left:</p>
<p><img src="images/chapter3/secrets.png" class="img-medium" /></p>
<p>Click <em>Generate/Import</em>. </p>
<p>For the secret name, enter <em>ConnectionStrings--DefaultConnection</em>. Copy and paste your conneciton string from the app configuration file for the value.</p>
<blockquote>
<p><strong>Secret Names Matter</strong></p>
<p>Go back and look at the app configuration file for Contoso University. You&#39;ll notice the JSON structure has a ConnectionStrings key following by a sub key of DefaultConnection. This is important. </p>
<p>In Key Vault, we&#39;ll mimick this struture by using the same key names and a double dash for the key name. Later, when we tell our web app to read the Key Vault secrets, it will be able to parse the secret name and dynamically replace the correct key/value pair in our configuration file.</p>
</blockquote>
<p><img src="images/chapter3/create-secret.png" /></p>
<p>Click <em>Create</em>.</p>
<p><img src="images/chapter3/created.png" /></p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div> 

<h3 id="incorporating-key-vault-access-into-web-apps">Incorporating Key Vault Access into Web Apps</h3>
<p>Now that we have secrets in our Key Vault, let&#39;s configure the web app to access the Key Vault. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Configuring a Web App to read configuration from a Key Vault
</h4>

<p>To configure the Contoso University app to read configuration data from the Key Vault, we need to modify the app&#39;s startup process to load it&#39;s current ocnfiguraiton file, then reach out to the Key Vault, read the secrets, and dynamically load the secret values into our configuration.</p>
<p>Let&#39;s start by adding a few NuGet packages to the ContosoUniversity project.</p>
<p>Right-click the Solution, and add the following packages. <strong>Be midful to add the specific version(s) we&#39;ve specified below!</strong></p>
<ul>
<li>Microsoft.Azure.Services.AppAuthentication, v1.2.0-preview2</li>
<li>Microsoft.Extensions.Configuration.AzureKeyVault, v2.2.0</li>
</ul>
<p>Next, create a new class in the root of the ContosoUniversity project named <code>PrefixKeyVaultSecretManager.cs</code>. Place the following code inside.</p>
<pre><code class="lang-c#">using Microsoft.Azure.KeyVault.Models;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Configuration.AzureKeyVault;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace ContosoUniversity
{
    public class PrefixKeyVaultSecretManager : IKeyVaultSecretManager
    {
        public string GetKey(SecretBundle secret)
        {
            // Remove the prefix from the secret name and replace two 
            // dashes in any name with the KeyDelimiter, which is the 
            // delimiter used in configuration (usually a colon). Azure 
            // Key Vault doesn&#39;t allow a colon in secret names.
            return secret.SecretIdentifier.Name
                .Replace(&quot;--&quot;, ConfigurationPath.KeyDelimiter);
        }

        public bool Load(SecretItem secret)
        {
            return true;
        }
    }
}
</code></pre>
<p>You can think of htis class as a <em>conversion</em> class. The <em>GetKey()</em> function is called each time a key/value pair is restrived from the Key Vault. The function then translates any double dashes into colons. This is an important step because .NET Core apps (like this one) natively translate colons into a heirarchical configuraiton file manner when parsing config values. </p>
<p>So, a value of <em>ConnectionStrings--DefaultConnection</em> is translated by the <em>GetKey()</em> function into <em>ConnectionStrings:DefaultConnection</em>. Then, .NET Core reads the string and replaces the configuration key of ConnectionStrings with sub key DefaultConnection with the value pulled from the Key Vault.</p>
<blockquote>
<p><strong>Why not use colons in the Key Vault secret?</strong></p>
<p>You may be wondering why we had to convert double dashes into colons. Unfortunately, key vault key names cannot contain colons, so some type of replacement delimiter must be used. I chose a double dash. </p>
</blockquote>
<p>Next, update the <em>CreateWebHostBuilder()</em> function in the <code>Program.cs</code> file to tie everything together. After updaitng the function, don&#39;t forget to add the missing references at top. </p>
<pre><code class="lang-c#">public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;
    WebHost.CreateDefaultBuilder(args)
        .ConfigureAppConfiguration((context, builder) =&gt;
        {
            // only run in &quot;production&quot; mode, so you don&#39;t override 
            // config values when running locally for development
            if (context.HostingEnvironment.IsProduction())
            {
                var config = builder.Build();

                // get MSI token from running web app
                var tokenProvider = new AzureServiceTokenProvider(); 

                // create kv client, passing MSI token for authorization
                var keyvaultClient = new KeyVaultClient((authority, resource, scope)
                    =&gt; tokenProvider.KeyVaultTokenCallback(authority, resource, scope));

                // add the Key Vault &quot;provider&quot; that scans the KV, loading secrets into configuration
                builder.AddAzureKeyVault(config[&quot;KeyVault:BaseUrl&quot;], keyvaultClient, new PrefixKeyVaultSecretManager());
            }
        })
        .UseStartup&lt;Startup&gt;();
</code></pre>
<p>These additional lines of code essentially does the following:</p>
<ol>
<li>Only runs the Key Vault loading code when runningin production (so you don&#39;t override your development settings)</li>
<li>Gets the MSI token from the running web app</li>
<li>Creates a client to talk to the Key Vault through, using the token for an authorization context</li>
<li>Adds the Key Vault &quot;provider&quot; into the pipeline that builds the configuration file. It also assumes a configuration file value of &quot;KeyVault:BaseUrl&quot; is present</li>
</ol>
<p>Finally, let&#39;s head on over to the configuration file and make a few changes:</p>
<p>Change the database connection string back to the MS SQL Local DB value (this way, we&#39;ll dev in our local environment):</p>
<pre><code>Server=(localdb)\\mssqllocaldb;Database=ContosoUniversity3;Trusted_Connection=True;MultipleActiveResultSets=true
</code></pre><p>Add a key/value pair for the <em>KeyVault:BaseUrl</em>. Be sure to substitute the URL of your Key Vault (you can find it in the Azure Portal).</p>
<pre><code class="lang-json">  &quot;KeyVault&quot;: {
    &quot;BaseUrl&quot;: &quot;{your_keyvault_url_goes_here}&quot;
  }
</code></pre>
<p>This is what my configuration file looks like when I&#39;m finished:</p>
<p><img src="images/chapter3/config.png" class="img-medium" /></p>
<p>To test your changes, run your app locally and add a new student. Then, publish your app to Azure. Navigate to the app&#39;s Azure URL and verify that the student you previously added isn&#39;t present.</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div> 

<h3 id="adding-authentication-to-your-app">Adding Authentication to your App</h3>
<p>Now that we&#39;ve secured our app&#39;s secrets in the Key Vault, it&#39;s time to worry about the app itself! So far, anybody can access Contoso University&#39;s site and make changes. Let&#39;s lock it down.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Adding Authentication to Contoso University&#39;s app
</h4>

<p>This is a lot easier than you may think ;-)</p>
<p>Navigate to your web app in the Azure portal and select the &quot;Authentication / Authorization&quot; option on the left.</p>
<p><img src="images/chapter3/auth.png" class="img-override" /></p>
<p>Change the <em>App Service Authentication</em> option to <em>On</em>, select <em>Log in with Azure Active Directory</em> form the drop down. Then, click <em>Azure Active Directory</em> authentication provider.</p>
<p>On the next screen, select <em>Express</em> management mode, and press <em>Ok</em>. Accept all other defaults.</p>
<p><img src="images/chapter3/aad-auth.png" class="img-medium" /></p>
<p>Press <em>Save</em> at top.</p>
<p>That&#39;s it. Your app is now secured by Azure Active Directory. Anyone trying to access the site willbe automatically prompted to login. Try it. The first time you access it, it will prompt you to login (or detect that you&#39;re already logged into the Azure portal with the same credentials) and ask you for consent to read your login profile. Accept it.</p>
<p><img src="images/chapter3/prompt.png" class="img-medium" /></p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div> 

<p>Phew. This was a long chapter, but you learned some important cloud-native ways of securing secrets with the Key Vault.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="decoupling-web-apps-from-data-access-with-a-rest-api-service-layer">Decoupling Web Apps from Data Access with a REST API Service Layer</h2>
<p>In this chapter, you&#39;ll learn how to:</p>
<ul>
<li>Create a Web API REST service that can be shared across applications</li>
<li>Remove direct data access from MVC controllers  </li>
<li>Use Swagger to create an easy-to-use REST API explorer</li>
</ul>
<h3 id="overview">Overview</h3>
<p>If you take a moment to investigate the ContosoUniversity MVC app, you&#39;ll notice that the MVC model and Entity Framework DbContext classes are split out in a shared library (ContosoUniversityData); however, much of the data access is being done in the controllers. This isn&#39;t &quot;wrong&quot;, and it&#39;s a valid approach for small, simple applications. </p>
<p>Althgouh not &quot;wrong&quot; it can reduce code reuse and encourge developers to re-write the same type of code over and over again. For example, let&#39;s assume Contoso&#39;s accounting department needs access to student data in their application - all of a sudden it becomes easier for the developers working on that project to tie directly into the database, or write their own DbContext. And, before you know it, there are 4 different applications all attached to this database, extracting and manipulating data separately. </p>
<p>This is wrong, and it&#39;s a code smell.</p>
<p>Now, imaging that one of these teams needs a change made to how Students are tracked - how do you manage that across all the disparate applications? This is how an innocent seemingly-innocuous change can affect an entire organization downstream. </p>
<p>So, what&#39;s a devleoper to do? </p>
<p>There are a number of approaches and architectural patterns that exist to combat this scenario. In today&#39;s workshop, we&#39;re going to take a very niave, first-step approach to decoupling the web UI layer from the data access layer by creating a Web API project that abstracts the data access into a single, re-usable place. When that&#39;s finished, you&#39;ll have a single (and versioned) interface to access Contoso University data.</p>
<p>Let&#39;s get started.</p>
<h3 id="creating-the-web-api-project">Creating the Web API Project</h3>
<p>Our first step is to create a Web API project.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Creating a Web API Project
</h4>

<p>In Visual Studio, add a new .NET Core 2.2 Web API Project to the existing solution.</p>
<p>Choose the <em>ASP.NET Core Web Application</em> project type from the <em>Add New Project</em> window:</p>
<p><img src="images/chapter4/select-project.png" class="img-override" /></p>
<p>Name the project <em>ContosoUniversityAPI</em>:</p>
<p><img src="images/chapter4/name-project.png" class="img-medium" /></p>
<p>For the project type, ensure you&#39;ve selected <em>ASP.NET Core 2.2</em> and <em>API</em>. Click <em>Create</em>:</p>
<p><img src="images/chapter4/project-type.png" class="img-override" /></p>
<h4 id="adding-the-key-vault-components-to-the-api">Adding the Key Vault components to the API</h4>
<p>Next, you&#39;ll have to back-track a bit and complete the same steps from the previous chapter related to the Key Vault components, but doing so for the Web API project. </p>
<p>I&#39;m not going to detail these steps for you here, because you can look. But I will give you the high-levle beats of what you&#39;ll be doing. Feel free to use this list as a TODO checklist:</p>
<ol>
<li>Copy the contents of the app configuration file into the API&#39;s config file </li>
<li>Add Key Vault related NuGet Packages </li>
<li>Add a reference to the ContosoUniversityData project</li>
<li>Add the <em>PrefixKeyVaultSecretManager</em> class (be sure to change the namespace if you&#39;re copy/pasting the actual file)</li>
<li>Update <em>Program.cs</em> to add Key Vault configuration to the API project</li>
</ol>
<h4 id="configuring-entity-framework">Configuring Entity Framework</h4>
<p>In addition to these steps, you&#39;ll also need to configure the Entity Framework School DbContext class for the API project.</p>
<p>Copy the contents of the <em>Program.cs Main()</em> function, and move it into the API project&#39;s <em>Program.cs</em> file.</p>
<p>Finally, replace the <em>Configuration()</em> function in <em>Startup.cs</em> with the following:</p>
<pre><code class="lang-c#">public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext&lt;SchoolContext&gt;(options =&gt;
        options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));

    services
        .AddMvc()
        .SetCompatibilityVersion(CompatibilityVersion.Version_2_2)
        .AddJsonOptions(
            options =&gt; options.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore
        );
}
</code></pre>
<p>These code changes register the School DbContext class and ensure JSON data returned by REST API is complete.</p>
<h4 id="testing-your-changes">Testing your changes</h4>
<p>Run the API project to test it. The Values Controller should return static values in a browser window:</p>
<p><img src="images/chapter4/values.png" /></p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>  

<h3 id="moving-web-controller-data-access">Moving Web Controller Data Access</h3>
<p>Next, we&#39;ll be moving select data access logic from the Student and Courses controllers into Student and Courses controllers in the API project. Let&#39;s get started.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: REST API Controller Creation and Moving Data Access Logic
</h4>

<blockquote>
<p><strong>You may have noticed...</strong></p>
<p>...there&#39;s a lot of data access logic in the Web controllers. I&#39;m not walking you through moving every controller action. Instead, we&#39;ll be moving 2 controller actions, and I&#39;ll leave the others up to you. Think of it as a challenge (and practice for doing this IRL).</p>
</blockquote>
<h4 id="api-project-values-controller">API Project - Values Controller</h4>
<p>Now that we know the API project runs, delete the Values controller - it&#39;s not needed.</p>
<h4 id="api-project-courses-controller">API Project - Courses Controller</h4>
<p>Let&#39;s start with the Courses controller. Create a Courses controller in the API project, then add the code below.</p>
<pre><code class="lang-c#">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using ContosoUniversityData.Data;
using ContosoUniversityData.Models;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace ContosoUniversityAPI.Controllers
{
    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class CoursesController : ControllerBase
    {
        private readonly SchoolContext _context;

        public CoursesController(SchoolContext context)
        {
            _context = context;
        }

        // GET: api/Courses
        [HttpGet]
        public IEnumerable&lt;Course&gt; Get()
        {
            var courses = _context.Courses
                .Include(c =&gt; c.Department)
                .AsNoTracking();
            return courses.ToList();
        }
    }
}
</code></pre>
<h4 id="api-project-students-controller">API Project - Students Controller</h4>
<p>Now, add a Students controller and the following code:</p>
<pre><code class="lang-c#">using System.Net;
using System.Threading.Tasks;
using ContosoUniversityData.Data;
using ContosoUniversityData.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace ContosoUniversityApi.Controllers
{
    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class StudentsController : ControllerBase
    {
        private readonly SchoolContext _context;

        public StudentsController(SchoolContext context)
        {
            _context = context;
        }

        // POST: api/Students
        [HttpPost]
        public async Task&lt;StatusCodeResult&gt; Post([FromBody] Student student)
        {
            try
            {
                _context.Add(student);
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateException /* ex */)
            {
                return new StatusCodeResult((int)HttpStatusCode.BadRequest);
            }
            return new StatusCodeResult((int)HttpStatusCode.Created);
        }

    }
}
</code></pre>
<h4 id="testing-your-changes">Testing your changes</h4>
<p>Finally, open the <em>launchSettings.json</em> file and modify the <em>launchUrl</em> value to be <em>api/Courses</em> in al places. Note - you will need to change it in 2 places.</p>
<p><img src="images/chapter4/launch-settings.png" class="img-small" /></p>
<p>As you can see, we added the HTTP GET for courses and HTTP POST for students. Run the API project to test your changes. You shoud see a list of Courses, returned as JSON:</p>
<p><img src="images/chapter4/courses.png" class="img-override" /></p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>  

<p>Now that you&#39;ve created the API project, it&#39;s time to refactor the Web project controllers to call the API project&#39;s REST endpoints instead of using Entity Framework.</p>
<p>Let&#39;s get to work.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Refactoring the Web project to call a REST API
</h4>

<p>Start with the Web Courses controller.</p>
<h4 id="web-project-courses-controller">Web Project - Courses Controller</h4>
<p>First, replace the CoursesController constructor with the following:</p>
<pre><code class="lang-c#">private readonly IConfiguration _configuration;

public CoursesController(SchoolContext context, IConfiguration configuration)
{
    _context = context;
    _configuration = configuration;
}
</code></pre>
<p>This will use ASP.NET Core&#39;s built-in dependency injection to obtain a reference to the app&#39;s configuration objects. </p>
<p>Next, replace the HTTP GET Index() method with the following:</p>
<pre><code class="lang-c#">// GET: Courses
public async Task&lt;IActionResult&gt; Index()
{
    using (var httpClient = new HttpClient())
    {
        try
        {
            httpClient.BaseAddress = new Uri(_configuration[&quot;Api:BaseAddress&quot;]);
            var response = await httpClient.GetAsync($&quot;{_configuration[&quot;Api:ApiPath&quot;]}/api/Courses&quot;);
            response.EnsureSuccessStatusCode();

            var stringResult = await response.Content.ReadAsStringAsync();

            var courses = JsonConvert.DeserializeObject&lt;IEnumerable&lt;Course&gt;&gt;(stringResult);
            return View(courses);
        }
        catch (HttpRequestException httpRequestException)
        {
            return BadRequest($&quot;Error getting request: {httpRequestException.Message}&quot;);
        }
    }
}
</code></pre>
<p>As you&#39;ll notice, this code creates an HTTP client, configures it to access a Uri (configured from the Api:BaseAddress configuration setting), then gets the resource at {Api:ApiPath}/api/Courses.</p>
<p>This means that we&#39;ll need to create a few configuration variables. Add values for Api:BaseAddress and Api:ApiPath to the configuration file:</p>
<pre><code class="lang-json">&quot;Api&quot;: {
    &quot;BaseAddress&quot;: &quot;https://localhost:XXXXX&quot;,
    &quot;ApiPath&quot;:  &quot;&quot;
}
</code></pre>
<blockquote>
<p><strong>BaseAdress needs customization</strong></p>
<p>You&#39;ll notice that the code snippet above has <a href="http://localhost:XXXXX">http://localhost:XXXXX</a> for the BaseAddress value. You&#39;ll need to replace the <em>XXXXX</em> with the port number your local API project is running on. Check the API project&#39;s launchSettings.json file for the <em>sslPort</em> value.</p>
</blockquote>
<p>You&#39;ll also notice that the Api:ApiPath value is empty - that&#39;s OK. Sometimes, IIS hosts APIs in a virtual directory - and in fact, we&#39;ll be using it in a later chapter.</p>
<h4 id="web-project-students-controller">Web Project - Students Controller</h4>
<p>Next, update the Students controller constructor with this code:</p>
<pre><code class="lang-c#">private readonly IConfiguration _configuration;

public StudentsController(SchoolContext context, IConfiguration configuration)
{
    _context = context;
    _configuration = configuration;
}
</code></pre>
<p>Then, update the HTTP POST Create() method:</p>
<pre><code class="lang-c#">// POST: Students/Create
// To protect from overposting attacks, please enable the specific properties you want to bind to, for 
// more details see http://go.microsoft.com/fwlink/?LinkId=317598.
[HttpPost]
[ValidateAntiForgeryToken]
public async Task&lt;IActionResult&gt; Create(
    [Bind(&quot;EnrollmentDate,FirstMidName,LastName&quot;)] Student student)
{
    if (ModelState.IsValid)
    {
        using (var httpClient = new HttpClient())
        {
            try
            {
                httpClient.BaseAddress = new Uri(_configuration[&quot;Api:BaseAddress&quot;]);
                var response = await httpClient.PostAsJsonAsync&lt;Student&gt;($&quot;{_configuration[&quot;Api:ApiPath&quot;]}/api/Students&quot;, student);
                response.EnsureSuccessStatusCode();
                return RedirectToAction(nameof(Index));
            }
            catch (HttpRequestException httpRequestException)
            {
                //Log the error (uncomment ex variable name and write a log.
                ModelState.AddModelError(&quot;&quot;, &quot;Unable to save changes. &quot; +
                    &quot;Try again, and if the problem persists &quot; +
                    &quot;see your system administrator.&quot;);
            }
        }
    }
    return View(student);
}
</code></pre>
<p>Just like the Course controller, the HttpClient class is used to make an HTTP request to the API project (using the same configuration variables).</p>
<h4 id="testing-your-changes">Testing your changes</h4>
<p>To run both projects at once, right-click the solution, navigate to the <em>Properties</em> page, and under <em>Startup Project</em>, select <em>Multiple startup projects</em> and <em>Start</em> for the Web and API projects.</p>
<p><img src="images/chapter4/multiple-startup.png" class="img-medium" /></p>
<p>Run the projects, then:</p>
<ul>
<li>Navigate to the Courses page</li>
<li>Try adding a Student</li>
</ul>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>  


<h3 id="using-swagger-to-build-an-api-definition">Using Swagger to Build an API Definition</h3>
<p>Having a REST API deployed somewhere is just fine, but you need other developers know how they can interact with the API. That&#39;s where Swagger Specifications (a.k.a. OpenAPI Specifications) come in.</p>
<h4 id="what-is-swagger-openapi-specification-">What is Swagger (OpenAPI) Specification?</h4>
<p>The OpenAPI Specification (OAS), formerly known as the Swagger Specification, is the world’s standard for defining RESTful interfaces. The OAS enables developers to design a technology-agnostic API interface that forms the basis of their API development and consumption.</p>
<p>You can learn more at <a href="https://swagger.io/resources/open-api/">Swagger&#39;s website</a> if you&#39;re interested, but in summary, Swagger provides tools that can scan your API project and create a common-language specification document (in JSON) that describes all available REST commands for your API.</p>
<p>Swagger is easy to use, so let&#39;s get started.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Adding Swagger to your API project
</h4>

<p>To add Swagger to your API project, add the following NuGet packages (and specific versions) to your API project:</p>
<ul>
<li>Swashbuckle.AspNetCore, v5.0.0-rc2</li>
<li>Swashbuckle.AspNetCore.Swagger, v5.0.0-rc2</li>
</ul>
<p>These packages add code generation capabilities to auto-generate a swagger.json file to describe your API and a middleware layer that hosts a Swagger UI to visualize and quickly test your API.</p>
<p>Next, update the <em>ConfigurationServices()</em> method of the Startup class:</p>
<pre><code class="lang-c#">// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext&lt;SchoolContext&gt;(options =&gt;
        options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));

    services
        .AddMvc()
        .SetCompatibilityVersion(CompatibilityVersion.Version_2_2)
        .AddJsonOptions(
            options =&gt; options.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore
        );

    // Register the Swagger generator, defining 1 or more Swagger documents
    services.AddSwaggerGen(c =&gt;
    {
        c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo { Title = &quot;ContosoUniversity&quot;, Version = &quot;v1&quot; });
    });
}
</code></pre>
<p>Then update the <em>Configure()</em> method:</p>
<pre><code class="lang-c#">// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
        app.UseHsts();
    }

    // Enable middleware to serve generated Swagger as a JSON endpoint.
    app.UseSwagger();

    // Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.), 
    // specifying the Swagger JSON endpoint.
    app.UseSwaggerUI(c =&gt;
    {
        c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;My API V1&quot;);
    });

    app.UseHttpsRedirection();
    app.UseMvc();
}
</code></pre>
<h4 id="testing-our-your-changes">Testing our your changes</h4>
<p>Launch the API project and navigate to <a href="https://localhost:XXXXX/swagger/v1/swagger.json">https://localhost:XXXXX/swagger/v1/swagger.json</a>. You should see a JSON file the browser:</p>
<p><img src="images/chapter4/swagger-json.png" class="img-medium" /></p>
<p>Next, navigate to <a href="https://localhost:XXXXX/swagger">https://localhost:XXXXX/swagger</a> to see the interactive UI:</p>
<p><img src="images/chapter4/swagger-ui.png" class="img-medium" /></p>
<p>Nice work! Take a few minutes to experiment with the Swagger UI - you&#39;l notice that it has scanned your .NET code and determined there are 2 API endpoints: api/courses and api/students. You can even try out calls to it dynamically via the UI.</p>
<p>Exciting!</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div> 

<h3 id="deploying-the-updated-projects-to-azure">Deploying the updated Projects to Azure</h3>
<p>Now that we&#39;ve tested our code locally, let&#39;s get it into Azure. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Deploying and testing in Azure
</h4>

<p>To deploy an test in Azure we have 3 steps:</p>
<ol>
<li>Publish the API project to a new Web App</li>
<li>Add the new secrets to our Key Vault (for Api:BaseAddress and Api:ApiPath)</li>
<li>Publish the Web project to the existing Web App</li>
</ol>
<p>Let&#39;s get started.</p>
<h4 id="publishing-the-api-project">Publishing the API project</h4>
<p>You&#39;ve done this before with the Web project, so follow the same steps to create a new Web App. A few things to remember as you go through this process:</p>
<ul>
<li>When creating the new Web App, take notes of it&#39;s URL</li>
<li>Use the same resource group you created earlier</li>
<li>You can reuse the Free App Plan</li>
</ul>
<p>After publishing the API project, you&#39;ll notice that the site won&#39;t load:</p>
<p><img src="images/chapter4/failure.png" class="img-override" /></p>
<p>That&#39;s because it cannot access your Key Vault! If you recall in the previous chapter, we added the Web project MSI to the access policies of the Key Vault. Now, we need to do the same steps for the API project. </p>
<p>I won&#39;t walk you through the details, but will outline the high-level steps and let you try it on your own:</p>
<ol>
<li>Add an MSI account to the API project you just created</li>
<li>Add this MSI account to the <em>Secrets Management</em> access policy on the Key Vault</li>
<li>Restart the API web app to have it attempt to access the Key Vault </li>
</ol>
<h4 id="updating-the-key-vault">Updating the Key Vault</h4>
<p>Navigate to the Secrets area of your Key Vault and add the following key/value pairs:</p>
<ul>
<li>Api--BaseAddress: the URL of the new API web app, mine was <a href="https://contoso-web-api-meb.azurewebsites.net">https://contoso-web-api-meb.azurewebsites.net</a></li>
<li>Api--ApiPath: {empty string, for now}</li>
</ul>
<p>Note: now that you&#39;ve added these values, you may need to restart the API web app again to have it read the updated values.</p>
<h4 id="publishing-the-web-project">Publishing the Web project</h4>
<p>You&#39;ve done this before, so just republish. If you need help, check back at an earlier chapter.</p>
<h4 id="testing-your-changes">Testing your changes</h4>
<p>After you&#39;ve published the Web Site, navigate to it and try to:</p>
<ul>
<li>View the list of courses</li>
<li>Add a new student</li>
</ul>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div> 


<p>In this chapter, you learned:</p>
<ul>
<li>How to create a Web API project to centralize data access</li>
<li>How to advertise REST APIs using Swagger</li>
<li>How to call REST APIs from a ASP.NET Core MVC app </li>
</ul>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="securing-rest-apis">Securing REST APIs</h2>
<p>In this chapter, you&#39;ll learn how to:</p>
<ul>
<li>Use Azure API Management to provide a secure wrapper around your REST APIs</li>
<li>Restrict access to Web Apps, only allowing API Management to communicate  </li>
</ul>
<h3 id="overview">Overview</h3>
<p>At the end of the previous chapter, you had successfully deployed a REST API to an Azure Web App. The REST API had also integrated Swagger to let other know how to consume the API. </p>
<p>Deploying the REST API was a great accomplishment. </p>
<p>Deploying the REST API without a security layer could be problematic. </p>
<p>In this chapter, you&#39;ll work to address the API security layer issue with an Azure service called API Management.</p>
<blockquote>
<p><strong>What is API Management?</strong></p>
<p>API Management (APIM) helps organizations publish APIs to external, partner, and internal developers to unlock the potential of their data and services. Businesses everywhere are looking to extend their operations as a digital platform, creating new channels, finding new customers and driving deeper engagement with existing ones. API Management provides the core competencies to ensure a successful API program through developer engagement, business insights, analytics, security, and protection. You can use Azure API Management to take any backend and launch a full-fledged API program based on it.</p>
</blockquote>
<p>Sounds pretty cool, right? It is, and it&#39;s easy. </p>
<h3 id="creating-an-api-management-service">Creating an API Management Service</h3>
<p>Creating an API Management service in Azure takes a little bit of time, so let&#39;s get started.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Creating an API Management Service
</h4>

<p>In the Azure portal, create a new <em>API Management Resource</em>. Choose a unique name for your resource. For other details, see below:</p>
<p><img src="images/chapter5/apim-create.png" /></p>
<p>Click <em>Create</em>, then wait. It will take a while to deploy API Management - maybe up to 10 minutes, so this is a great opportunity to learn about securing your API project.</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div> 

<h3 id="restricting-access-to-web-apps">Restricting Access to Web Apps</h3>
<p>As I&#39;ve discussed earlier, exposing a REST API service to the entire internet without any controls/restrictions in place isn&#39;t a great idea. </p>
<p>Let&#39;s learn how we can restrict access through the Azure portal.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Exploring Access Restrictions on Web Apps
</h4>

<p>Navigate to your deployed API project and find the <em>Networking</em> section of the Web App service. At the bottom of the page, click on the <em>Configure Access Restrictions</em> link:</p>
<p><img src="images/chapter5/access-restrictions.png" /></p>
<p>On the Access Restrictions page, you have the ability to add firewall rules that restrict which IP addresses can access this service. This provides you with an easy way to ensure only certain individuals (or other Azure services) have access to your APIs.</p>
<p><img src="images/chapter5/def-access-restrictions.png" /></p>
<p>As you can see, all internet traffic is allowed to access my API web app. </p>
<p>When your API Management Service is provisioned, it will have a Virtual IP address assigned to it - with that IP address, you&#39;ll be able to create a firewall rule that only allows traffic from API Management. </p>
<p>We&#39;ll revisit this page in the future. For now, take a break until API Management has finished deploying. Read through the next section as you&#39;re waiting.</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>


<h3 id="learning-about-api-management">Learning about API Management</h3>
<p>Before we can start using the APIM service, there&#39;s a few concepts you should understand.</p>
<p>To use API Management, administrators create APIs. Each API consists of one or more operations, and each API can be added to one or more products. To use an API, developers subscribe to a product that contains that API, and then they can call the API&#39;s operation, subject to any usage policies that may be in effect. Common scenarios include:</p>
<ul>
<li><strong>Securing mobile infrastructure</strong> by gating access with API keys, preventing DOS attacks by using throttling, or using advanced security policies like JWT token validation.</li>
<li><strong>Enabling ISV partner ecosystems</strong> by offering fast partner onboarding through the developer portal and building an API facade to decouple from internal implementations that are not ripe for partner consumption.</li>
<li><strong>Running an internal API program</strong> by offering a centralized location for the organization to communicate about the availability and latest changes to APIs, gating access based on organizational accounts, all based on a secured channel between the API gateway and the backend.</li>
</ul>
<p>The system is made up of the following components:</p>
<ul>
<li><p><strong>The API gateway</strong> is the endpoint that:</p>
<ul>
<li>Accepts API calls and routes them to your backends.</li>
<li>Verifies API keys, JWT tokens, certificates, and other credentials.</li>
<li>Enforces usage quotas and rate limits.</li>
<li>Transforms your API on the fly without code modifications.</li>
<li>Caches backend responses where set up.</li>
<li>Logs call metadata for analytics purposes.</li>
</ul>
</li>
<li><p><strong>The Azure portal</strong> is the administrative interface where you set up your API program. Use it to:</p>
<ul>
<li>Define or import API schema.</li>
<li>Package APIs into products.</li>
<li>Set up policies like quotas or transformations on the APIs.</li>
<li>Get insights from analytics.</li>
<li>Manage users.</li>
</ul>
</li>
<li><p><strong>The Developer portal</strong> serves as the main web presence for developers, where they can:</p>
<ul>
<li>Read API documentation.</li>
<li>Try out an API via the interactive console.</li>
<li>Create an account and subscribe to get API keys.</li>
<li>Access analytics on their own usage.</li>
</ul>
</li>
</ul>
<h4 id="apis-and-operations">APIs and operations</h4>
<p>APIs are the foundation of an API Management service instance. Each API represents a set of operations available to developers. Each API contains a reference to the back-end service that implements the API, and its operations map to the operations implemented by the back-end service. Operations in API Management are highly configurable, with control over URL mapping, query and path parameters, request and response content, and operation response caching. Rate limit, quotas, and IP restriction policies can also be implemented at the API or individual operation level.</p>
<h4 id="products">Products</h4>
<p>Products are how APIs are surfaced to developers. Products in API Management have one or more APIs, and are configured with a title, description, and terms of use. Products can be Open or Protected. Protected products must be subscribed to before they can be used, while open products can be used without a subscription. When a product is ready for use by developers, it can be published. Once it is published, it can be viewed (and in the case of protected products subscribed to) by developers. Subscription approval is configured at the product level and can either require administrator approval, or be auto-approved.</p>
<p>Groups are used to manage the visibility of products to developers. Products grant visibility to groups, and developers can view and subscribe to the products that are visible to the groups in which they belong.</p>
<h4 id="groups">Groups</h4>
<p>Groups are used to manage the visibility of products to developers. API Management has the following immutable system groups:</p>
<ul>
<li><p><strong>Administrators</strong> - Azure subscription administrators are members of this group. Administrators manage API Management service instances, creating the APIs, operations, and products that are used by developers.</p>
</li>
<li><p><strong>Developers</strong> - Authenticated developer portal users fall into this group. Developers are the customers that build applications using your APIs. Developers are granted access to the developer portal and build applications that call the operations of an API.</p>
</li>
<li><p><strong>Guests</strong> - Unauthenticated developer portal users, such as prospective customers visiting the developer portal of an API Management instance fall into this group. They can be granted certain read-only access, such as the ability to view APIs but not call them.</p>
</li>
</ul>
<p>In addition to these system groups, administrators can create custom groups or leverage external groups in associated Azure Active Directory tenants. Custom and external groups can be used alongside system groups in giving developers visibility and access to API products. For example, you could create one custom group for developers affiliated with a specific partner organization and allow them access to the APIs from a product containing relevant APIs only. A user can be a member of more than one group.</p>
<h4 id="developers">Developers</h4>
<p>Developers represent the user accounts in an API Management service instance. Developers can be created or invited to join by administrators, or they can sign up from the Developer portal. Each developer is a member of one or more groups, and can subscribe to the products that grant visibility to those groups.</p>
<p>When developers subscribe to a product, they are granted the primary and secondary key for the product. This key is used when making calls into the product&#39;s APIs.</p>
<h4 id="policies">Policies</h4>
<p>Policies are a powerful capability of API Management that allow the Azure portal to change the behavior of the API through configuration. Policies are a collection of statements that are executed sequentially on the request or response of an API. Popular statements include format conversion from XML to JSON and call rate limiting to restrict the number of incoming calls from a developer, and many other policies are available.</p>
<p>Policy expressions can be used as attribute values or text values in any of the API Management policies, unless the policy specifies otherwise. Some policies such as the Control flow and Set variable policies are based on policy expressions. </p>
<h4 id="developer-portal">Developer portal</h4>
<p>The developer portal is where developers can learn about your APIs, view and call operations, and subscribe to products. Prospective customers can visit the developer portal, view APIs and operations, and sign up. The URL for your developer portal is located on the dashboard in the Azure portal for your API Management service instance.</p>
<p>You can customize the look and feel of your developer portal by adding custom content, customizing styles, and adding your branding.</p>
<h3 id="creating-your-first-api">Creating your first API</h3>
<p>By now, your APIM service should have deployed. If not, take a break and continue once it&#39;s ready.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Creating your first API
</h4>

<p>Earlier in this chapter you learned about APIM and how you can create an API that talks to a backend API. In this exercise, we&#39;ll be creating an APIM API that references your Contoso University REST API hosted in Azure. </p>
<p>Navigate to your APIM service and click the <em>APIs</em> option. Click the box <em>OpenAPI</em> under the <em>Add a new API</em> heading:</p>
<p><img src="images/chapter5/add-api.png" class="img-override" /></p>
<blockquote>
<p><strong>Swagger Specifications and OpenAPI</strong></p>
<p>You may recall that Swagger Specifications were renamed to OpenAPI Specifications. You&#39;ll also recall that we added Swagger definitions to our API project. The OpenAPI option you just selected will let us reference the swagger.json files produced by Swagger to create an API in APIM automatically.</p>
</blockquote>
<p>Click the <em>Full</em> link at top and complete the necessary fields, including:</p>
<ul>
<li>OpenAPI specification: URL to your swagger.json file hsoted on your API web app</li>
<li>Display Name</li>
<li>Name</li>
<li>URL Scheme: restrict to HTTPS</li>
<li>API URL suffix: set this to <em>contoso</em>, which is the URL route developers will use to access your API</li>
<li>Version this API?: check the box</li>
</ul>
<p><img src="images/chapter5/openapi.png" class="img-override" /></p>
<p>It&#39;s important that you version your APIs. APIM provides many ways of versioning your API (via URL route, HTTP Headers, and query strings). I prefer the URL route, but what you choose is ultimately up to you.</p>
<p>At the very bottom, you can see a preview URL of what developers will use as the base URL when communicating with your API. For example, mine says <a href="https://contoso-university-meb.azure-api.net/contoso/v1">https://contoso-university-meb.azure-api.net/contoso/v1</a>. This base URL will be combined with my Azure-hosted API web app URL routing scheme (i.e., /api/Courses and /api/Students), so the final URL other developers will use will look like this: <a href="https://contoso-university-meb.azure-api.net/contoso/v1/api/Courses">https://contoso-university-meb.azure-api.net/contoso/v1/api/Courses</a>. </p>
<p>When an HTTP request is made to that URL, the APIM gateway willintercept the call, very the caller has permissions to access the API, then forward the request to the backend API (in this case <a href="https://contoso-web-api-meb.azurewebsites.net/api/Courses)">https://contoso-web-api-meb.azurewebsites.net/api/Courses)</a>. When the backend API responds, it is routed back through the APIM gateway and back to the original caller.</p>
<p>Click <em>Create</em> to finish.</p>
<p>When APIM finishes creating the API gateway route, you&#39;re presented with detailed HTTP operations the APIM servie detected (via your Swagger file).</p>
<p><img src="images/chapter5/api-v1.png" class="img-override" /></p>
<p>You can customize the data/routing/behavior of your API here, if you choose. This is out of scope for our workshop, but I encourage you to explore on your own.</p>
<h4 id="finishing-the-configuration">Finishing the configuration</h4>
<p>Click the <em>Settings</em> tab of the newly-created API, and type the backend URL of your API into the <em>Web service URL</em> field. For me this was <em><a href="https://contoso-web-api-meb.azurewebsites.net">https://contoso-web-api-meb.azurewebsites.net</a></em>:</p>
<p><img src="images/chapter5/web-url.png" class="img-override" /></p>
<p>Also select <em>Unlimited</em> from the <em>Products</em> area.</p>
<p>Click <em>Save</em>.</p>
<blockquote>
<p><strong>Unlimited Product</strong></p>
<p>The unlimited product is a pre-created APIM product that gives developers unlimited access (without network throttling or other policies applied). It is also a product that requires Administrative appoval. So, when someone subscribes to the product, a request is sent to the API administrator, and it must be approved before the developer obtains an API subscription key.</p>
</blockquote>
<h4 id="testing-your-apim-gateway">Testing your APIM gateway</h4>
<p>Next, click the <em>Test</em> tab, then select the GET /api/Course command. </p>
<p><img src="images/chapter5/test.png" class="img-override" /></p>
<p>Here, you&#39;ll see a test client to testing your API. The <em>Request URL</em> is the URL that an HTTP GET will be sent to when you click the <em>Send</em> button at the bottom. </p>
<p>Click the <em>Send</em> button and you should see an HTTP 200 Success message:</p>
<p><img src="images/chapter5/success.png" class="img-override" /></p>
<h4 id="testing-with-a-3rd-party-tool">Testing with a 3rd party tool</h4>
<p>It&#39;s normally a good idea to test access to your API from another tool. I happen to like Postman. Visit <a href="https://www.getpostman.com/">https://www.getpostman.com/</a> to download Postman. </p>
<p>After downloading and installing, create an HTTP GET request, and fill in the URL of your APIM API. For example, mine was <a href="https://contoso-university-meb.azure-api.net/contoso/v1/api/Courses">https://contoso-university-meb.azure-api.net/contoso/v1/api/Courses</a>.</p>
<p>Click <em>Send</em>.</p>
<p><img src="images/chapter5/postman-no-auth.png" class="img-override" /></p>
<p>As you can see, the response at the bottom says:</p>
<pre><code class="lang-json">{
    &quot;statusCode&quot;: 401,
    &quot;message&quot;: &quot;Access denied due to missing subscription key. Make sure to include subscription key when making requests to an API.&quot;
}
</code></pre>
<p>This is exactly what I&#39;d expect, because I didn&#39;t supply a subscription key. When we placed the API behind the APIM gateway, it requires we submit a subscription key in the HTTP request header.</p>
<p>Let&#39;s try this again. We&#39;ll need to add an HTTP header named <em>Ocp-Apim-Subscription-Key</em> with a subscription key as the value. </p>
<p>To get a subscription key, navigate back to the APIM service, and click <em>Developer portal</em>. When the portal loads, you will be logged in as the portal Administrator. </p>
<p>Click your name in the upper-right and navigate to your profile. On the profile page, locate the Unlimited subscription (this is auto-assigned to you as an administrator), and click <em>Show</em>. Copy the subscription key and save it.</p>
<p><img src="images/chapter5/portal.png" class="img-override" /></p>
<p>Return to Postman and create the key/value pair of:</p>
<ul>
<li>Ocp-Apim-Subscription-Key: {your subscription key}</li>
</ul>
<p>Click <em>Send</em>.</p>
<p><img src="images/chapter5/200ok.png" class="img-override" /></p>
<p>This time, you&#39;ll notice the request was processed by the gateway, forwarded to the backend API, and returned a list of courses.</p>
<h4 id="challenge">Challenge</h4>
<p>If you&#39;re up for a challenge, find a friend in the workshop that has also deployed APIM. Pretend you&#39;re a developer wanting access to their API. </p>
<p>Get the URL of their developer portal, navigate to it, create a login, request an Unlimited product subscription, and make a successful request to their API.</p>
<h4 id="challenge-2">Challenge #2</h4>
<p>If you&#39;re up for a second challenge, customize the look and feel of your portal. </p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>

<h3 id="restrict-access-to-the-backend-api">Restrict Access to the Backend API</h3>
<p>You&#39;ll recall that we had reviewed the Access Restrictions section of your backend API web app earlier in this chapter. Let&#39;s follow-through with our plans to prevent anyone from casually querying the backend directly by resticting access to the APIM virtual IP address.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Restricting Backend API Access
</h4>

<p>Navigate to the <em>Overview</em> section of your APIM service and locate the <em>Virtual IP (VIP) Addresses</em>:</p>
<p><img src="images/chapter5/vip.png" class="img-medium" /></p>
<p>Copy the VIP.</p>
<p>Next, navigate back tot he Access Restrictions area of your backend API web app. Add an <em>Allow</em> rule for the VIP you copied:</p>
<p><img src="images/chapter5/ip-restriction.png" class="img-medium" /></p>
<p>Click <em>Add rule</em>. You&#39;l notice that the restrictions now show that all traffic is denied with the exception of the APIM VIP you just set:</p>
<p><img src="images/chapter5/deny.png" class="img-medium" /></p>
<h4 id="testing-the-restrictions">Testing the restrictions</h4>
<p>To test the changes, navigate to your backend API URL directly from your browser. You should receive an error message.</p>
<p><img src="images/chapter5/error403.png" class="img-medium" /></p>
<p>Now, return to Postman and re-run your last HTTP GET request and verify that it succeeds.</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>

<p>In this chapter, you learned:</p>
<ul>
<li>How to use APIM to greate a secure API gateway for your REST API.</li>
<li>How to restrict access to your REST API so only APIM can communicate with it.</li>
</ul>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="consuming-a-secure-rest-api">Consuming a Secure REST API</h2>
<p>In this chapter, you&#39;ll learn:</p>
<ul>
<li>How to modify your Web project to communicate to a backend API via APIM</li>
</ul>
<h3 id="overview">Overview</h3>
<p>In the last chapter, you deployed a secure API using API Management, then restricted access to your REST API so only API Management could communicate with it. </p>
<p>This is fantastic! But...now the Contoso University web app you deployed cannot talk to the backend API directly.</p>
<p>In this chapte,r we&#39;ll refactor the REST API access code slightly to communicate to the backend API via the APIM gateway.</p>
<h3 id="refactoring-rest-api-access">Refactoring REST API Access</h3>
<p>To communicate through the APIM gateway, you&#39;ll need to update the code in the Contoso University web app. Let&#39;s get started!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Update the web app
</h4>

<p>There are a number of steps you&#39;ll need to accomplish to ensure the deployed Contoso University web app can speak through the APIM gateway:</p>
<ol>
<li>Update Key Vault with new Api:BaseAddress, Api:SubscriptionKey, and Api:ApiPath values</li>
<li>Add a blank Api:SubscriptionKey key/value pair to the app configuration file</li>
<li>Refactor the httpClient code to pass the <em>Ocp-Apim-Subscription-Key</em> header with each request</li>
</ol>
<h4 id="updating-key-vault-secrets">Updating Key Vault secrets</h4>
<p>Navigate to the Key Vault you deployed earlier, and add/update the following keys with their new values:</p>
<ul>
<li>Api--BaseAddress: change this to the URL of your API Management gateway, mine was <a href="https://contoso-university-meb.azure-api.net">https://contoso-university-meb.azure-api.net</a></li>
<li>Api--ApiPath: /contoso/v1</li>
<li>Api--SubscriptionKey: the subscription key you copied from the Developer portal in the previous chapter</li>
</ul>
<h4 id="add-a-black-api-subscriptionkey-key-value-pair">Add a black Api:SubscriptionKey key/value pair</h4>
<p>Open the web project&#39;s configuration file and add a &quot;SubscriptionKey&quot;: &quot;&quot; key/value pair to the &quot;Api&quot; section. It should now look like:</p>
<pre><code class="lang-json">&quot;Api&quot;: {
    &quot;BaseAddress&quot;: &quot;https://localhost:XXXXX&quot;,
    &quot;SubscriptionKey&quot;: &quot;&quot;,
    &quot;ApiPath&quot;: &quot;&quot;
}
</code></pre>
<h4 id="refactor-controllers-to-include-the-ocp-apim-subscription-key-http-header">Refactor controllers to include the Ocp-Apim-Subscription-Key HTTP header</h4>
<p>Open the Students contoller and update the Create() function to:</p>
<pre><code class="lang-c#">// more details see http://go.microsoft.com/fwlink/?LinkId=317598.
[HttpPost]
[ValidateAntiForgeryToken]
public async Task&lt;IActionResult&gt; Create(
    [Bind(&quot;EnrollmentDate,FirstMidName,LastName&quot;)] Student student)
{
    if (ModelState.IsValid)
    {
        using (var httpClient = new HttpClient())
        {
            try
            {
                httpClient.BaseAddress = new Uri(_configuration[&quot;Api:BaseAddress&quot;]);
                httpClient.DefaultRequestHeaders.Add(&quot;Ocp-Apim-Subscription-Key&quot;, _configuration[&quot;Api:SubscriptionKey&quot;]);
                var response = await httpClient.PostAsJsonAsync&lt;Student&gt;($&quot;{_configuration[&quot;Api:ApiPath&quot;]}/api/Students&quot;, student);
                response.EnsureSuccessStatusCode();
                return RedirectToAction(nameof(Index));
            }
            catch (HttpRequestException httpRequestException)
            {
                //Log the error (uncomment ex variable name and write a log.
                ModelState.AddModelError(&quot;&quot;, &quot;Unable to save changes. &quot; +
                    &quot;Try again, and if the problem persists &quot; +
                    &quot;see your system administrator.&quot;);
            }
        }
    }
    return View(student);
}
</code></pre>
<p>Then, open the Courses controller and update it&#39;s Index() method to:</p>
<pre><code class="lang-c#">// GET: Courses
public async Task&lt;IActionResult&gt; Index()
{
    using (var httpClient = new HttpClient())
    {
        try
        {
            httpClient.BaseAddress = new Uri(_configuration[&quot;Api:BaseAddress&quot;]);
            httpClient.DefaultRequestHeaders.Add(&quot;Ocp-Apim-Subscription-Key&quot;, _configuration[&quot;Api:SubscriptionKey&quot;]);
            var response = await httpClient.GetAsync($&quot;{_configuration[&quot;Api:ApiPath&quot;]}/api/Courses&quot;);
            response.EnsureSuccessStatusCode();

            var stringResult = await response.Content.ReadAsStringAsync();

            var courses = JsonConvert.DeserializeObject&lt;IEnumerable&lt;Course&gt;&gt;(stringResult);
            return View(courses);
        }
        catch (HttpRequestException httpRequestException)
        {
            return BadRequest($&quot;Error getting request: {httpRequestException.Message}&quot;);
        }
    }
}
</code></pre>
<h4 id="testing-your-changes">Testing your changes</h4>
<p>Redeploy the ContosoUniversity web app to Azure and visit the site to make sure it still works.</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>

<p>Congratulations! You&#39;ve successfully secured your API and accessed it from another application. </p>

			</div>
			<hr>
			<br />
			<br />
			<br />
			<br />
		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>